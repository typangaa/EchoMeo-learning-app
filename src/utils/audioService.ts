/**
 * Audio Service for Vietnamese-Chinese Learning Platform
 * This service handles playing pre-generated audio files
 */

// Import audio mapping (this will be generated by the Python script)
// If the file doesn't exist yet, create an empty object structure
let audioMapping: {
  vocabulary: {
    vietnamese: Record<string, string>;
    chinese: Record<string, string>;
  };
  passages: {
    vietnamese?: {
      titles?: Record<string, string>;
      paragraphs?: Record<string, Record<string, string>>;
    };
    chinese?: {
      titles?: Record<string, string>;
      paragraphs?: Record<string, Record<string, string>>;
    };
  };
};

try {
  audioMapping = require('../data/audio_mapping.json');
} catch (error) {
  // Create empty mapping if file doesn't exist yet
  audioMapping = {
    vocabulary: {
      vietnamese: {},
      chinese: {}
    },
    passages: {}
  };
  console.warn('Audio mapping file not found. Audio functionality will be limited.');
}

interface AudioServiceOptions {
  baseUrl?: string;
  defaultVolume?: number;
  useFallback?: boolean;
}

class AudioService {
  private baseUrl: string;
  private audioElement: HTMLAudioElement | null = null;
  private volume: number;
  private useFallback: boolean;
  private webSpeechAvailable: boolean;

  constructor(options: AudioServiceOptions = {}) {
    this.baseUrl = options.baseUrl || '/audio/';
    this.volume = options.defaultVolume || 1.0;
    this.useFallback = options.useFallback !== false; // Default to true
    
    // Check if Web Speech API is available as fallback
    this.webSpeechAvailable = typeof window !== 'undefined' && 
                             'speechSynthesis' in window &&
                             'SpeechSynthesisUtterance' in window;
    
    // Initialize audio element
    if (typeof window !== 'undefined') {
      this.audioElement = new Audio();
      this.audioElement.volume = this.volume;
    }
  }

  /**
   * Play an audio file for the given text and language
   */
  public playText(text: string, language: 'vietnamese' | 'chinese'): Promise<void> {
    return new Promise(async (resolve, reject) => {
      if (!this.audioElement) {
        reject(new Error('Audio not supported in this environment'));
        return;
      }
      
      try {
        // Try to find and play the offline audio file first
        const audioFile = this.findAudioFile(text, language);
        
        if (audioFile) {
          await this.playAudioFile(audioFile);
          resolve();
          return;
        }
        
        // If no audio file found and fallback is enabled, try Web Speech API
        if (this.useFallback && this.webSpeechAvailable) {
          await this.playTextWithWebSpeech(text, language);
          resolve();
          return;
        }
        
        // No audio file and no fallback
        reject(new Error(`No audio available for "${text}"`));
      } catch (error) {
        console.error('Error playing audio:', error);
        reject(error);
      }
    });
  }

  /**
   * Play a title audio for a specific passage
   */
  public playPassageTitle(passageId: string, language: 'vietnamese' | 'chinese'): Promise<void> {
    return new Promise(async (resolve, reject) => {
      const titlePath = this.findPassageAudio(passageId, language, 'title');
      if (titlePath) {
        try {
          await this.playAudioFile(titlePath);
          resolve();
        } catch (error) {
          reject(error);
        }
      } else {
        // Try to find the title text to use as fallback
        const passages = require('../data/reading/a1Readings').default;
        const passage = passages.find((p: any) => p.id === passageId);
        
        if (passage && passage.title && passage.title[language]) {
          this.playText(passage.title[language], language)
            .then(resolve)
            .catch(reject);
        } else {
          reject(new Error(`No title audio for passage ${passageId}`));
        }
      }
    });
  }

  /**
   * Play a paragraph audio for a specific passage
   */
  public playPassageParagraph(passageId: string, paragraphIndex: number, language: 'vietnamese' | 'chinese'): Promise<void> {
    return new Promise(async (resolve, reject) => {
      const paragraphPath = this.findPassageAudio(passageId, language, 'paragraph', paragraphIndex);
      if (paragraphPath) {
        try {
          await this.playAudioFile(paragraphPath);
          resolve();
        } catch (error) {
          reject(error);
        }
      } else {
        // Try to find the paragraph text to use as fallback
        const passages = require('../data/reading/a1Readings').default;
        const passage = passages.find((p: any) => p.id === passageId);
        
        if (passage && 
            passage.paragraphs && 
            passage.paragraphs[paragraphIndex] && 
            passage.paragraphs[paragraphIndex][language]) {
          this.playText(passage.paragraphs[paragraphIndex][language], language)
            .then(resolve)
            .catch(reject);
        } else {
          reject(new Error(`No paragraph audio for passage ${passageId} paragraph ${paragraphIndex}`));
        }
      }
    });
  }

  /**
   * Play an audio file at the given path
   */
  private playAudioFile(audioPath: string): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.audioElement) {
        reject(new Error('Audio not supported'));
        return;
      }
      
      // Set up event handlers
      const handleEnded = () => {
        this.audioElement?.removeEventListener('ended', handleEnded);
        this.audioElement?.removeEventListener('error', handleError);
        resolve();
      };
      
      const handleError = (error: Event) => {
        this.audioElement?.removeEventListener('ended', handleEnded);
        this.audioElement?.removeEventListener('error', handleError);
        console.error('Error playing audio:', error);
        reject(new Error('Failed to play audio file'));
      };
      
      this.audioElement.addEventListener('ended', handleEnded);
      this.audioElement.addEventListener('error', handleError);
      
      // Set the audio source and play
      this.audioElement.src = `${this.baseUrl}${audioPath}`;
      this.audioElement.play().catch(error => {
        console.error('Error playing audio:', error);
        reject(error);
      });
    });
  }

  /**
   * Find the audio file path for the given text and language
   */
  private findAudioFile(text: string, language: 'vietnamese' | 'chinese'): string | null {
    // Direct lookup in our mapping
    const langMapping = audioMapping.vocabulary[language];
    if (langMapping[text]) {
      return langMapping[text];
    }
    
    // Try with trimmed text
    const trimmedText = text.trim();
    if (trimmedText !== text && langMapping[trimmedText]) {
      return langMapping[trimmedText];
    }
    
    // No audio file found
    return null;
  }

  /**
   * Find audio file for a passage title or paragraph
   */
  private findPassageAudio(
    passageId: string, 
    language: 'vietnamese' | 'chinese', 
    type: 'title' | 'paragraph',
    paragraphIndex?: number
  ): string | null {
    if (!audioMapping.passages[language]) {
      return null;
    }
    
    if (type === 'title' && audioMapping.passages[language]?.titles) {
      return audioMapping.passages[language]?.titles?.[passageId] || null;
    }
    
    if (type === 'paragraph' && 
        paragraphIndex !== undefined && 
        audioMapping.passages[language]?.paragraphs) {
      return audioMapping.passages[language]?.paragraphs?.[passageId]?.[paragraphIndex.toString()] || null;
    }
    
    return null;
  }

  /**
   * Use Web Speech API as fallback
   */
  private playTextWithWebSpeech(text: string, language: 'vietnamese' | 'chinese'): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.webSpeechAvailable) {
        reject(new Error('Web Speech API not available'));
        return;
      }
      
      const utterance = new SpeechSynthesisUtterance(text);
      
      // Set language code
      if (language === 'vietnamese') {
        utterance.lang = 'vi-VN';
      } else {
        utterance.lang = 'zh-CN';
      }
      
      // Set volume
      utterance.volume = this.volume;
      
      // Set rate (slightly slower for learning)
      utterance.rate = language === 'vietnamese' ? 0.9 : 0.8;
      
      // Handle events
      utterance.onend = () => resolve();
      utterance.onerror = (event) => reject(new Error(`Speech synthesis error: ${event.error}`));
      
      // Speak
      window.speechSynthesis.speak(utterance);
    });
  }

  /**
   * Set the volume for audio playback
   */
  public setVolume(volume: number): void {
    this.volume = Math.max(0, Math.min(1, volume));
    if (this.audioElement) {
      this.audioElement.volume = this.volume;
    }
  }

  /**
   * Stop any currently playing audio
   */
  public stop(): void {
    if (this.audioElement) {
      this.audioElement.pause();
      this.audioElement.currentTime = 0;
    }
    
    // Also stop any web speech synthesis
    if (this.webSpeechAvailable) {
      window.speechSynthesis.cancel();
    }
  }

  /**
   * Preload audio files for improved performance
   */
  public preloadAudio(text: string, language: 'vietnamese' | 'chinese'): void {
    const audioFile = this.findAudioFile(text, language);
    if (audioFile) {
      const audio = new Audio();
      audio.src = `${this.baseUrl}${audioFile}`;
      // Just load it but don't play
      audio.load();
    }
  }

  /**
   * Check if audio is available for a specific text
   */
  public hasAudio(text: string, language: 'vietnamese' | 'chinese'): boolean {
    return this.findAudioFile(text, language) !== null || this.webSpeechAvailable;
  }
}

// Create and export a singleton instance
const audioService = new AudioService();
export default audioService;